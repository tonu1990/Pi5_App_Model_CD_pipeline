# .github/workflows/deploy-to-pi.yml
name: Deploy Application to Pi (Web App or GUI App)

on:
  workflow_dispatch:
    inputs:
      application-type:
        description: "Choose the Application type (WEB App or GUI App)"
        type: choice
        options:
          - Web App
          - GUI App
        required: true
        default: Web App

      image-name:
        description: "GHCR image name (e.g. ghcr.io/owner/app)."
        required: true
        type: string
        default: ""

      tag:
        description: "Image tag"
        required: false
        type: string
        default: "latest"

      container-name:
        description: "Human-friendly name for Pi for Application container"
        required: true
        type: string
        default: "EdgeAI Pi5 Demo"

      model-mount-dir:
        description: "Host model directory to mount to App-Leave blank to use /opt/edge/<repo_name>"
        required: false
        type: string
        default: ""

      host-port:
        description: "(WEB App ONLY) Host port on the Pi"
        required: true
        type: string
        default: "8080"

      container-port:
        description: "(WEB App ONLY) Container port (default 8080). Input the actual port used while building the application image"
        required: true
        type: string
        default: "8080"

      icon-name:
        description: "(GUI APP ONLY) App launch icon name (Menu icon/Desktop icon)"
        required: true
        type: string
        default: "EdgeAI_Pi5"

      extra-args:
        description: "Optional: extra docker run args (e.g., --device /dev/video0 --group-add video -e KEY=VAL)"
        required: false
        type: string
        default: ""

jobs:
  deploy-to-pi:
    # This runs on your self-hosted Pi runner
    runs-on: [self-hosted, pi5, app_model_cd]

    steps:
      - name: Checkout (needed to read repo name for defaults)
        uses: actions/checkout@v4

      - name: Resolve inputs (build IMAGE_REF, compute SLUG, pick model dir)
        id: resolve
        shell: bash
        run: |
          set -euo pipefail

          # --- 1) Read raw inputs ---
          APP_TYPE="${{ inputs['application-type'] }}"
          IMAGE_IN="${{ inputs['image-name'] }}"
          TAG_IN="${{ inputs.tag }}"
          CN_HUMAN="${{ inputs['container-name'] }}"
          ICON_NAME="${{ inputs['icon-name'] }}"
          MODEL_DIR_IN="${{ inputs['model-mount-dir'] }}"
          HOST_PORT_IN="${{ inputs['host-port'] }}"
          CONT_PORT_IN="${{ inputs['container-port'] }}"
          EXTRA_ARGS="${{ inputs['extra-args'] }}"
          REPO_NAME="${{ github.event.repository.name }}"

          # --- 2) Build final IMAGE_REF (digest > tag-in-image > supplied tag) ---
          # If image includes @sha256:..., use as-is
          if [[ "$IMAGE_IN" == *@sha256:* ]]; then
            IMAGE_REF="$IMAGE_IN"
          # If image already has :tag (and it's not part of a path), use as-is
          elif [[ "$IMAGE_IN" =~ :[^/]+$ ]]; then
            IMAGE_REF="$IMAGE_IN"
          # Otherwise, append :<tag> (default 'latest')
          else
            IMAGE_REF="${IMAGE_IN}:${TAG_IN:-latest}"
          fi

          # --- 3) Slug the human-friendly container name into a safe system name ---
          # Slug rules (simple and predictable for PoC):
          # - lowercase
          # - spaces -> dashes
          # - drop anything not [a-z0-9._-]
          # - collapse multiple dashes
          # - trim leading/trailing dashes/underscores/dots
          # - fallback to "app" if empty
          SLUG="$(printf '%s' "$CN_HUMAN" \
            | tr '[:upper:]' '[:lower:]' \
            | sed -E 's/[[:space:]]+/-/g; s/[^a-z0-9._-]//g; s/-+/-/g; s/^[-_.]+//; s/[-_.]+$//' )"
          [[ -n "$SLUG" ]] || SLUG="app"
          # Optional: limit to 63 chars for safety
          SLUG="${SLUG:0:63}"

          # --- 4) icon-name fallback (GUI label shown to users) ---
          if [[ -z "$ICON_NAME" ]]; then
            ICON_NAME="$CN_HUMAN"
          fi

          # --- 5) Model directory on host ---
          if [[ -n "$MODEL_DIR_IN" ]]; then
            HOST_MODEL_DIR="$MODEL_DIR_IN"
          else
            HOST_MODEL_DIR="/opt/edge/${REPO_NAME}"
          fi

          # --- 6) Ports (Web App only) ---
          # Keep them as strings for now; we validate later only if "Web App"
          HOST_PORT="$HOST_PORT_IN"
          CONTAINER_PORT="$CONT_PORT_IN"

          # --- 7) Save for later steps ---
          {
            echo "APP_TYPE=$APP_TYPE"
            echo "IMAGE_REF=$IMAGE_REF"
            echo "SLUG=$SLUG"
            echo "ICON_NAME=$ICON_NAME"
            echo "HOST_MODEL_DIR=$HOST_MODEL_DIR"
            echo "HOST_PORT=$HOST_PORT"
            echo "CONTAINER_PORT=$CONTAINER_PORT"
            echo "EXTRA_ARGS=$EXTRA_ARGS"
          } >> "$GITHUB_OUTPUT"

          # --- 8) Short summary for humans (appears in job summary tab) ---
          {
            echo "### Inputs resolved"
            echo ""
            echo "| Key | Value |"
            echo "|---|---|"
            echo "| Application type | \`$APP_TYPE\` |"
            echo "| Image reference | \`$IMAGE_REF\` |"
            echo "| Container name (slug) | \`$SLUG\` |"
            echo "| Icon name (GUI) | \`$ICON_NAME\` |"
            echo "| Host model dir | \`$HOST_MODEL_DIR\` |"
            echo "| Host port (Web) | \`$HOST_PORT\` |"
            echo "| Container port (Web) | \`$CONTAINER_PORT\` |"
            echo "| Extra args | \`$EXTRA_ARGS\` |"
          } >> "$GITHUB_STEP_SUMMARY"

      # If your image is private, add a GHCR login step here.
      # For a PoC with public images, we keep it simple and skip auth.

      - name: Pull Docker image (common step for both types)
        shell: bash
        run: |
          set -euo pipefail
          docker pull "${{ steps.resolve.outputs.IMAGE_REF }}"

      - name: Verify model dir exists
        shell: bash
        run: |
          set -euo pipefail
          DIR="${{ steps.resolve.outputs.HOST_MODEL_DIR }}"
          if [[ -d "$DIR" ]]; then
            echo "✅ Model directory exists: $DIR"
            # Optional: warn if current.onnx missing (some apps can still start)
            if [[ ! -e "$DIR/current.onnx" ]]; then
              echo "⚠️  Warning: $DIR/current.onnx not found. App may start without a model."
            fi
          else
            echo "⚠️  Warning: Model directory does not exist yet: $DIR"
          fi

      # =========================
      # === Branch: Web App =====
      # =========================
      - name: Web App | Validate ports and stop existing container
        if: ${{ steps.resolve.outputs.APP_TYPE == 'Web App' }}
        shell: bash
        run: |
          set -euo pipefail
          NAME="${{ steps.resolve.outputs.SLUG }}"
          HPORT="${{ steps.resolve.outputs.HOST_PORT }}"
          CPORT="${{ steps.resolve.outputs.CONTAINER_PORT }}"

          # Basic numeric validation for a beginner-friendly PoC
          [[ "$HPORT" =~ ^[0-9]+$ ]] || { echo "HOST_PORT must be numeric (got '$HPORT')"; exit 1; }
          [[ "$CPORT" =~ ^[0-9]+$ ]] || { echo "CONTAINER_PORT must be numeric (got '$CPORT')"; exit 1; }

          # Check if host port is already in use by a different container
          CONFLICTS=$(docker ps --format '{{.Names}} {{.Ports}}' \
            | grep -E "0\.0\.0\.0:${HPORT}->|\\[::\\]:${HPORT}->" \
            | awk '{print $1}' \
            | grep -v "^${NAME}$" || true)
          if [[ -n "$CONFLICTS" ]]; then
            echo "❌ Host port ${HPORT} is in use by: ${CONFLICTS}"
            exit 1
          fi

          # Stop/remove container with the same name (idempotent)
          docker stop "$NAME" >/dev/null 2>&1 || true
          docker rm   "$NAME" >/dev/null 2>&1 || true
          echo "Previous container (if any) is stopped/removed."

      - name: Web App | Run container as a daemon
        if: ${{ steps.resolve.outputs.APP_TYPE == 'Web App' }}
        shell: bash
        run: |
          set -euo pipefail
          NAME="${{ steps.resolve.outputs.SLUG }}"
          IMG="${{ steps.resolve.outputs.IMAGE_REF }}"
          HPORT="${{ steps.resolve.outputs.HOST_PORT }}"
          CPORT="${{ steps.resolve.outputs.CONTAINER_PORT }}"
          MODELDIR="${{ steps.resolve.outputs.HOST_MODEL_DIR }}"
          EXTRA='${{ steps.resolve.outputs.EXTRA_ARGS }}'

          # Split extra-args into an array (if provided)
          if [[ -n "$EXTRA" ]]; then
            # shellcheck disable=SC2206
            EXTRA_ARR=($EXTRA)
          else
            EXTRA_ARR=()
          fi

          docker run -d \
            --name "$NAME" \
            --restart unless-stopped \
            -p "${HPORT}:${CPORT}" \
            -e MODEL_DIR=/models \
            -e MODEL_PATH=/models/current.onnx \
            -v "${MODELDIR}:/models:ro" \
            "${EXTRA_ARR[@]}" \
            "$IMG"

          echo "Container started: $NAME"

      - name: Web App | Quick health probe (best-effort)
        if: ${{ steps.resolve.outputs.APP_TYPE == 'Web App' }}
        shell: bash
        run: |
          set -euo pipefail
          HPORT="${{ steps.resolve.outputs.HOST_PORT }}"
          NAME="${{ steps.resolve.outputs.SLUG }}"

          # Give the app a few seconds to boot
          sleep 8

          if curl -fsS --max-time 5 "http://localhost:${HPORT}/health" >/dev/null; then
            echo "✅ /health endpoint responding"
          elif curl -fsS --max-time 5 "http://localhost:${HPORT}/" >/dev/null; then
            echo "✅ Root endpoint responding"
          else
            echo "⚠️  Health check failed (this may be fine if your app has no HTTP endpoint)"
            echo "Recent logs:"
            docker logs --tail 40 "$NAME" || true
          fi

      - name: Web App | Cleanup old images (keep newest 3)
        if: ${{ steps.resolve.outputs.APP_TYPE == 'Web App' }}
        shell: bash
        run: |
          set -euo pipefail
          # Clean only images belonging to the same repository (without tag/digest)
          # Extract the repo (left side of ':') from IMAGE_REF if present.
          REF="${{ steps.resolve.outputs.IMAGE_REF }}"
          REPO="${REF%%:*}"  # this is safe when REF is 'repo:tag'; for digests it still gives a sensible root

          echo "Cleaning older images for $REPO (keep newest 3)..."
          OLD_IMAGES=$(docker images "$REPO" --format "{{.ID}} {{.Repository}}:{{.Tag}} {{.CreatedAt}}" \
            | sort -k3 -r | tail -n +4 | awk '{print $1}' || true)
          if [[ -n "$OLD_IMAGES" ]]; then
            # shellcheck disable=SC2086
            docker rmi $OLD_IMAGES || echo "Some images could not be removed (may be in use)."
          else
            echo "No old images to remove."
          fi

      - name: Web App | Summary
        if: ${{ steps.resolve.outputs.APP_TYPE == 'Web App' }}
        shell: bash
        run: |
          set -euo pipefail
          NAME="${{ steps.resolve.outputs.SLUG }}"
          IMG="${{ steps.resolve.outputs.IMAGE_REF }}"
          HPORT="${{ steps.resolve.outputs.HOST_PORT }}"
          CPORT="${{ steps.resolve.outputs.CONTAINER_PORT }}"
          MODELDIR="${{ steps.resolve.outputs.HOST_MODEL_DIR }}"

          STATUS=$(docker inspect --format='{{.State.Status}}' "$NAME" 2>/dev/null || echo "unknown")

          {
            echo "## Web App Deployment"
            echo ""
            echo "| Key | Value |"
            echo "|---|---|"
            echo "| Image | \`$IMG\` |"
            echo "| Container | \`$NAME\` |"
            echo "| Ports | \`$HPORT:$CPORT\` |"
            echo "| Model mount | \`$MODELDIR -> /models\` |"
            echo "| Status | \`$STATUS\` |"
          } >> "$GITHUB_STEP_SUMMARY"

      # =========================
      # === Branch: GUI App =====
      # =========================
      - name: GUI App | Require passwordless sudo (we install files under /usr/local and /usr/share)
        if: ${{ steps.resolve.outputs.APP_TYPE == 'GUI App' }}
        shell: bash
        run: |
          if ! sudo -n true 2>/dev/null; then
            echo "This step needs passwordless sudo on the runner to write system paths." >&2
            exit 1
          fi

      - name: GUI App | Install helpers (best-effort)
        if: ${{ steps.resolve.outputs.APP_TYPE == 'GUI App' }}
        shell: bash
        run: |
          set -euo pipefail
          sudo apt-get update -y
          sudo apt-get install -y xdg-utils || true

      - name: GUI App | Install launcher script and desktop entry
        if: ${{ steps.resolve.outputs.APP_TYPE == 'GUI App' }}
        shell: bash
        run: |
          set -euo pipefail

          # Read resolved values
          SLUG="${{ steps.resolve.outputs.SLUG }}"
          ICON_NAME="${{ steps.resolve.outputs.ICON_NAME }}"
          IMG="${{ steps.resolve.outputs.IMAGE_REF }}"
          MODELDIR="${{ steps.resolve.outputs.HOST_MODEL_DIR }}"
          EXTRA='${{ steps.resolve.outputs.EXTRA_ARGS }}'

          # Paths we will create
          LAUNCHER="/usr/local/bin/${SLUG}.sh"
          DESKTOP_SYS="/usr/share/applications/${SLUG}.desktop"

          # --- Create launcher script ---
          TMP="$(mktemp)"
          cat > "$TMP" <<'EOSH'
          #!/usr/bin/env bash
          # Beginner note: this script is called when you click the desktop/menu icon.
          # It starts the Dockerized GUI app as the *current user* and wires up X11 and the camera.

          set -euo pipefail

          DOCKER=/usr/bin/docker
          ID=/usr/bin/id
          XHOST=/usr/bin/xhost

          IMAGE="__IMAGE__"
          NAME="__NAME__"
          HOST_MODEL_DIR="__HOST_MODEL_DIR__"
          EXTRA_ARGS_PLACEHOLDER="__EXTRA_ARGS__"

          LOG="/tmp/${NAME}.log"

          # 1) Pick a camera device (very simple PoC: prefer /dev/video0)
          DEVICE=""
          if [[ -n "${CAM_DEVICE:-}" ]]; then
            DEVICE="$CAM_DEVICE"
          elif [[ -e /dev/video0 ]]; then
            DEVICE="/dev/video0"
          elif ls -1 /dev/video* >/dev/null 2>&1; then
            DEVICE="$(ls -1 /dev/video* | head -n1)"
          fi

          # 2) Prepare X (GUI) environment variables and runtime dir
          export DISPLAY="${DISPLAY:-:0}"
          export XDG_RUNTIME_DIR="/tmp/runtime-$("$ID" -u)"
          mkdir -p "$XDG_RUNTIME_DIR" /tmp/.cache

          # Allow local user access to X server (best-effort)
          $XHOST +SI:localuser:$("$ID" -un) >/dev/null 2>&1 || true

          # 3) Build docker args (array) with safe defaults
          ARGS=(
            --rm
            --name "$NAME"
            --user "$("$ID" -u):$("$ID" -g)"
            -e DISPLAY="$DISPLAY"
            -e HOME=/tmp
            -e XDG_CACHE_HOME=/tmp/.cache
            -e XDG_RUNTIME_DIR="$XDG_RUNTIME_DIR"
            -e MODEL_DIR=/models
            -e MODEL_PATH=/models/current.onnx
            -v /tmp/.X11-unix:/tmp/.X11-unix:ro
            -v "$HOST_MODEL_DIR:/models:ro"
          )

          # Camera is optional—only add if we found one
          if [[ -n "$DEVICE" ]]; then
            ARGS+=( --device "$DEVICE:$DEVICE" --group-add video )
          fi

          # 4) Append user-provided extra args last (so they can override defaults)
          if [[ -n "$EXTRA_ARGS_PLACEHOLDER" ]]; then
            # shellcheck disable=SC2206
            EXTRA_ARR=($EXTRA_ARGS_PLACEHOLDER)
            ARGS+=( "${EXTRA_ARR[@]}" )
          fi

          # 5) Run the container
          exec "$DOCKER" run "${ARGS[@]}" "$IMAGE" >>"$LOG" 2>&1
          EOSH

          # Fill in template variables
          sed -i "s|__IMAGE__|$IMG|g" "$TMP"
          sed -i "s|__NAME__|$SLUG|g" "$TMP"
          sed -i "s|__HOST_MODEL_DIR__|$MODELDIR|g" "$TMP"
          sed -i "s|__EXTRA_ARGS__|$EXTRA|g" "$TMP"

          # Install launcher
          sudo install -m 0755 "$TMP" "$LAUNCHER"
          rm -f "$TMP"

          # --- Create a system .desktop entry (shows up in menus) ---
          TMPD="$(mktemp)"
          cat > "$TMPD" <<EOF
          [Desktop Entry]
          Type=Application
          Name=${ICON_NAME}
          Comment=Launch ${ICON_NAME}
          Exec=${LAUNCHER}
          Icon=utilities-camera
          Terminal=false
          Categories=Graphics;Video;
          StartupNotify=false
          EOF

          sudo install -m 0644 "$TMPD" "$DESKTOP_SYS"
          rm -f "$TMPD"

          # Best-effort: refresh desktop database
          command -v xdg-desktop-menu >/dev/null && xdg-desktop-menu forceupdate || true
          command -v update-desktop-database >/dev/null && sudo update-desktop-database || true

          echo "Installed launcher: $LAUNCHER"
          echo "Installed desktop entry: $DESKTOP_SYS"

      - name: GUI App | Summary
        if: ${{ steps.resolve.outputs.APP_TYPE == 'GUI App' }}
        shell: bash
        run: |
          set -euo pipefail
          {
            echo "## GUI App Installation"
            echo ""
            echo "| Key | Value |"
            echo "|---|---|"
            echo "| Image | \`${{ steps.resolve.outputs.IMAGE_REF }}\` |"
            echo "| Container (slug) | \`${{ steps.resolve.outputs.SLUG }}\` |"
            echo "| Launcher | \`/usr/local/bin/${{ steps.resolve.outputs.SLUG }}.sh\` |"
            echo "| Desktop entry | \`/usr/share/applications/${{ steps.resolve.outputs.SLUG }}.desktop\` |"
            echo "| Model mount | \`${{ steps.resolve.outputs.HOST_MODEL_DIR }} -> /models\` |"
            echo ""
            echo "_Note: The container runs **when you click** the desktop/menu icon._"
          } >> "$GITHUB_STEP_SUMMARY"
