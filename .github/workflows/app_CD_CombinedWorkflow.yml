# .github/workflows/deploy-to-pi5.yml
name: App CD - Deploy App Image from GHCR to Pi5

on:
  workflow_dispatch:
    inputs:
      image-name:
        description: "Application image name (from GHCR) to deploy -leave blank to use repo variable IMAGE_NAME"
        required: false
        type: string
        default: ""
      container-name:
        description: "Name to use Pi for Application container -leave blank to use APP_NAME from .env or 'pi_app'"
        required: false
        type: string
        default: ""
      host-port:
        description: "Host port in Pi where Application is to be deployed -leave blank to use HOST_PORT from .env"
        required: false
        type: string
        default: ""
      tag:
        description: "Image tag"
        required: false
        type: string
        default: "latest"

      model-mount-dir:
        description: "Model mount directory on Pi - leave blank to use /opt/edge/<repo_name>"
        required: false
        type: string
        default: ""

      extra-args:
        description: "Additional Docker run arguments (e.g., --env KEY=VAL)"
        required: false
        type: string
        default: ""


jobs:
  deploy-to-pi:
    runs-on: [self-hosted, pi5, app_model_cd]

    steps:
      - uses: actions/checkout@v4

      - name: Load .env (if present)
        shell: bash
        run: |
          set -euo pipefail
          if [ -f .env ]; then
            if grep -q '^[[:space:]]*[A-Za-z_][A-Za-z0-9_]*[[:space:]]*=' .env; then
              set -a
              # shellcheck disable=SC1091
              . ./.env
              set +a
            else
              echo "Found .env, but no VAR=VALUE lines were detected. Skipping."
            fi
          fi
          echo "APP_NAME=${APP_NAME:-}"   >> "$GITHUB_ENV"
          echo "HOST_PORT=${HOST_PORT:-}" >> "$GITHUB_ENV"
          echo "APP_PORT=${APP_PORT:-}"   >> "$GITHUB_ENV"

      - name: Resolve deployment parameters
        id: resolve
        shell: bash
        run: |
          set -euo pipefail

          IN_IMAGE="${{ inputs['image-name'] }}"
          IN_NAME="${{ inputs['container-name'] }}"
          IN_HOST="${{ inputs['host-port'] }}"
          IN_TAG="${{ inputs.tag }}"
          IN_MODEL_DIR="${{ inputs['model-mount-dir'] }}"

          VAR_IMAGE="${{ vars.IMAGE_NAME }}"

          # Decide image name: input > repo variable
          if [ -n "$IN_IMAGE" ]; then
            IMAGE_NAME="$IN_IMAGE"
          else
            if [ -z "$VAR_IMAGE" ]; then
              echo "ERROR: Repository variable IMAGE_NAME is not set, and no image-name input was provided."
              echo "Set Settings â†’ Variables â†’ Repository variables â†’ IMAGE_NAME (e.g., 'ghcr.io/<owner>/<repo>' or just '<repo>')."
              exit 1
            fi
            IMAGE_NAME="$VAR_IMAGE"
          fi
          # Prefix ghcr.io/<owner>/ if bare
          if [[ "$IMAGE_NAME" != ghcr.io/* ]]; then
            IMAGE_NAME="ghcr.io/${{ github.repository_owner }}/$IMAGE_NAME"
          fi

          # Container name: input > .env APP_NAME > default
          CONTAINER_NAME="${IN_NAME:-${APP_NAME:-pi_app}}"

          # Ports:
          HOST_PORT_VAL="${IN_HOST:-${HOST_PORT:-8000}}"
          CONT_PORT_VAL="${APP_PORT:-8080}"  # single source of truth from .env, fallback 8080

          # Model directory: input > default to /opt/edge/<repo_name>
          if [ -n "$IN_MODEL_DIR" ]; then
            MODEL_DIR="$IN_MODEL_DIR"
          else
            REPO_NAME="${{ github.event.repository.name }}"
            MODEL_DIR="/opt/edge/${REPO_NAME}"
          fi

          # Validate numerics
          [[ "$HOST_PORT_VAL" =~ ^[0-9]+$ ]] || { echo "HOST_PORT must be numeric (got '$HOST_PORT_VAL')"; exit 1; }
          [[ "$CONT_PORT_VAL" =~ ^[0-9]+$ ]] || { echo "APP_PORT must be numeric (got '$CONT_PORT_VAL')"; exit 1; }

          TAG="${IN_TAG:-latest}"
          FULL_IMAGE_REF="${IMAGE_NAME}:${TAG}"

          {
            echo "IMAGE_NAME=$IMAGE_NAME"
            echo "CONTAINER_NAME=$CONTAINER_NAME"
            echo "HOST_PORT=$HOST_PORT_VAL"
            echo "CONTAINER_PORT=$CONT_PORT_VAL"
            echo "TAG=$TAG"
            echo "FULL_IMAGE_REF=$FULL_IMAGE_REF"
            echo "MODEL_DIR=$MODEL_DIR"
          } >> "$GITHUB_OUTPUT"

          {
            echo "### Deployment parameters"
            echo ""
            echo "| Key | Value |"
            echo "|---|---|"
            echo "| Image | \`${FULL_IMAGE_REF}\` |"
            echo "| Container name | \`${CONTAINER_NAME}\` |"
            echo "| Host port | \`${HOST_PORT_VAL}\` |"
            echo "| Container port | \`${CONT_PORT_VAL}\` |"
            echo "| Model directory | \`${MODEL_DIR}\` |"
          } >> "$GITHUB_STEP_SUMMARY"

      - name: Log in to GitHub Container Registry
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Pull Docker image
        run: docker pull "${{ steps.resolve.outputs.FULL_IMAGE_REF }}"

      - name: Stop and remove old container with same name (if exists)
        shell: bash
        run: |
          docker stop "${{ steps.resolve.outputs.CONTAINER_NAME }}" || true
          docker rm   "${{ steps.resolve.outputs.CONTAINER_NAME }}" || true

      - name: Check for host-port conflicts
        shell: bash
        run: |
          set -euo pipefail
          PORT="${{ steps.resolve.outputs.HOST_PORT }}"
          NAME="${{ steps.resolve.outputs.CONTAINER_NAME }}"
          CONFLICTS=$(docker ps --format '{{.Names}} {{.Ports}}' \
            | grep -E "0\.0\.0\.0:${PORT}->|\\[::\\]:${PORT}->" \
            | awk '{print $1}' \
            | grep -v "^${NAME}$" || true)
          if [ -n "$CONFLICTS" ]; then
            echo "ERROR: Host port ${PORT} is already in use by: ${CONFLICTS}"
            echo "Pick a different host port or stop the conflicting container(s)."
            exit 1
          fi

      - name: Verify model mount directory exists on Pi
        shell: bash
        run: |
          MODEL_DIR="${{ steps.resolve.outputs.MODEL_DIR }}"
          test -d "$MODEL_DIR" || { echo "Missing model directory: $MODEL_DIR"; exit 1; }
          ls -l "$MODEL_DIR" || true
          readlink -f "$MODEL_DIR/current.onnx" || echo "Note: current.onnx not set yet in $MODEL_DIR"

      - name: Run new container
        shell: bash
        run: |
          set -euo pipefail
          EXTRA='${{ inputs.extra-args }}'
          if [ -n "$EXTRA" ]; then
            # shellcheck disable=SC2206
            EXTRA_ARR=($EXTRA)
          else
            EXTRA_ARR=()
          fi

          docker run -d \
            --name "${{ steps.resolve.outputs.CONTAINER_NAME }}" \
            --restart unless-stopped \
            -p "${{ steps.resolve.outputs.HOST_PORT }}:${{ steps.resolve.outputs.CONTAINER_PORT }}" \
            -e MODEL_PATH="${{ steps.resolve.outputs.MODEL_DIR }}/current.onnx" \
            -v "${{ steps.resolve.outputs.MODEL_DIR }}:${{ steps.resolve.outputs.MODEL_DIR }}:ro" \
            "${EXTRA_ARR[@]}" \
            "${{ steps.resolve.outputs.FULL_IMAGE_REF }}"

      - name: Verify container is running
        shell: bash
        run: |
          set -euo pipefail
          CONTAINER_NAME="${{ steps.resolve.outputs.CONTAINER_NAME }}"
          
          # Wait a few seconds for container to start
          sleep 5
          
          # Check if container is running
          if docker ps --filter "name=${CONTAINER_NAME}" --filter "status=running" --format '{{.Names}}' | grep -q "^${CONTAINER_NAME}$"; then
            echo "âœ… Container ${CONTAINER_NAME} is running successfully"
            docker ps --filter "name=${CONTAINER_NAME}" --format "table {{.Names}}\t{{.Status}}\t{{.Ports}}"
          else
            echo "âŒ Container ${CONTAINER_NAME} failed to start or is not running"
            echo "Container status:"
            docker ps -a --filter "name=${CONTAINER_NAME}" --format "table {{.Names}}\t{{.Status}}"
            echo "Container logs:"
            docker logs "${CONTAINER_NAME}" || echo "No logs available"
            exit 1
          fi

      - name: Health check (optional)
        shell: bash
        run: |
          set -euo pipefail
          HOST_PORT="${{ steps.resolve.outputs.HOST_PORT }}"
          CONTAINER_NAME="${{ steps.resolve.outputs.CONTAINER_NAME }}"
          
          echo "Performing health check on port ${HOST_PORT}..."
          
          # Wait for application to initialize
          sleep 10
          
          # Try basic connectivity test (adjust endpoint as needed)
          if curl -f -s --max-time 5 "http://localhost:${HOST_PORT}/health" > /dev/null 2>&1; then
            echo "âœ… Health check passed - application is responding"
          elif curl -f -s --max-time 5 "http://localhost:${HOST_PORT}/" > /dev/null 2>&1; then
            echo "âœ… Basic connectivity check passed - root endpoint responding"
          else
            echo "âš ï¸  Health/connectivity check failed - this may be normal if no health endpoint exists"
            echo "Application may still be starting up. Check logs:"
            docker logs --tail 10 "${CONTAINER_NAME}"
            echo "Note: This is not necessarily an error if your app doesn't have a health endpoint"
          fi

      - name: Cleanup old images
        shell: bash
        run: |
          set -euo pipefail
          IMAGE_NAME="${{ steps.resolve.outputs.IMAGE_NAME }}"
          
          echo "Cleaning up old images for ${IMAGE_NAME}..."
          
          # Get all images for this repository, sort by created date (newest first), skip first 3, remove the rest
          OLD_IMAGES=$(docker images "${IMAGE_NAME}" --format "{{.ID}} {{.CreatedAt}}" | \
            sort -k2 -r | tail -n +4 | awk '{print $1}' || true)
          
          if [ -n "$OLD_IMAGES" ]; then
            echo "Removing old images: $OLD_IMAGES"
            # shellcheck disable=SC2086
            docker rmi $OLD_IMAGES || echo "Some images could not be removed (may be in use)"
          else
            echo "No old images to clean up"
          fi

      - name: Deployment summary
        shell: bash
        run: |
          set -euo pipefail
          
          CONTAINER_NAME="${{ steps.resolve.outputs.CONTAINER_NAME }}"
          FULL_IMAGE_REF="${{ steps.resolve.outputs.FULL_IMAGE_REF }}"
          HOST_PORT="${{ steps.resolve.outputs.HOST_PORT }}"
          CONTAINER_PORT="${{ steps.resolve.outputs.CONTAINER_PORT }}"
          MODEL_DIR="${{ steps.resolve.outputs.MODEL_DIR }}"
          
          # Get container status
          STATUS=$(docker inspect --format='{{.State.Status}}' "${CONTAINER_NAME}" 2>/dev/null || echo "unknown")
          
          {
            echo "## ðŸš€ Deployment Summary"
            echo ""
            echo "| Parameter | Value |"
            echo "|-----------|-------|"
            echo "| **Image** | \`${FULL_IMAGE_REF}\` |"
            echo "| **Container** | \`${CONTAINER_NAME}\` |"
            echo "| **Port Mapping** | \`${HOST_PORT}:${CONTAINER_PORT}\` |"
            echo "| **Model Path** | \`${MODEL_DIR}/current.onnx\` |"
            echo "| **Status** | \`${STATUS}\` |"
            echo ""
            echo "### Container Details"
            echo "\`\`\`"
            docker ps --filter "name=${CONTAINER_NAME}" --format "table {{.Names}}\t{{.Status}}\t{{.Ports}}\t{{.Image}}" || true
            echo "\`\`\`"
            echo ""
            if [ "$STATUS" = "running" ]; then
              echo "âœ… **Deployment successful!** Your application is running at http://localhost:${HOST_PORT}"
            else
              echo "âŒ **Deployment issue detected.** Container status: ${STATUS}"
            fi
          } >> "$GITHUB_STEP_SUMMARY"
          
          echo "=== Deployment Complete ==="
          echo "âœ… Image: ${FULL_IMAGE_REF}"
          echo "âœ… Container: ${CONTAINER_NAME}"
          echo "âœ… Port: ${HOST_PORT}:${CONTAINER_PORT}"
          echo "âœ… Model: ${MODEL_DIR}/current.onnx"
          echo "âœ… Status: ${STATUS}"
          echo "=========================="
